#!/data/data/com.termux/files/usr/bin/bash
# Origami Kernel Manager
# Version 1.0.0
# Copyright (c) 2023-2024 Rem01 Gaming <Rem01_Gaming@proton.me>
#
#			GNU GENERAL PUBLIC LICENSE
#			 Version 3, 29 June 2007
#
# Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
# Everyone is permitted to copy and distribute verbatim copies
# of this license document, but changing it is not allowed.

# TODO:
# - Add more SoCs support
# - Make an setup template with json

# Text coloring
NOCOLOR='\033[0m'
RED='\033[0;31m'
GREEN='\033[0;32m'
ORANGE='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
LIGHTGRAY='\033[0;37m'
DARKGRAY='\033[1;30m'
LIGHTRED='\033[1;31m'
LIGHTGREEN='\033[1;32m'
YELLOW='\033[1;33m'
LIGHTBLUE='\033[1;34m'
LIGHTPURPLE='\033[1;35m'
LIGHTCYAN='\033[1;36m'
WHITE='\033[1;37m'
BLACKBGWHITE='\e[30;47m'

####### CHECKING NODE ######

# Check dependencies
if ! hash awk fzf uname getprop whoami 2>/dev/null; then
	echo -e "${RED}[!] hash awk fzf uname getprop whoami\nerror:${NOCOLOR} Environment has missing dependencies" && exit 127
fi

# TODO: Check capabilities
# Check the Root
if [[ ! $(whoami) == "root" ]]; then
	echo -e "${RED}FATAL:${NOCOLOR} Please run this script with sudo" && exit 126
fi

which_chipset() {
	export chipset=$(grep "Hardware" /proc/cpuinfo | uniq | cut -d ':' -f 2 | sed 's/^[ \t]*//')

	if [[ $chipset == *MT* ]]; then
		export soc=mtk
	elif [[ $chipset == *MSM* || $chipset == *QCOM* ]]; then
		export soc=qcom
	else
		echo -e "${LIGHTCYAN}Sorry, your chipset is unsupported :(${NOCOLOR}" && exit 1
	fi
}

####### MISC UTILS NODE #######

# Usage: fzf_select "options" "prompt"
fzf_select() {
	options=($(echo $1))
	selected_option=$(printf "%s\n" "${options[@]}" | fzf --reverse --cycle --prompt "$2")
	echo $selected_option
}

color_blocks() {
	colors=(
		"\e[48;5;0m   \e[0m" "\e[48;5;1m   \e[0m" "\e[48;5;2m   \e[0m" "\e[48;5;3m   \e[0m"
		"\e[48;5;4m   \e[0m" "\e[48;5;5m   \e[0m" "\e[48;5;6m   \e[0m" "\e[48;5;7m   \e[0m"
		"\e[48;5;8m   \e[0m" "\e[48;5;9m   \e[0m" "\e[48;5;10m   \e[0m" "\e[48;5;11m   \e[0m"
		"\e[48;5;12m   \e[0m" "\e[48;5;13m   \e[0m" "\e[48;5;14m   \e[0m" "\e[48;5;15m   \e[0m"
	)

	for ((i=0; i<${#colors[@]}; i+=8)); do
		for ((j=i; j<i+8; j++)); do
			echo -ne "${colors[$j]}"
		done
		echo
	done
}

gradient_line() {
	#start_color="F4BDD2ff"
	#end_color="E3B7FAff"

	start_color=$1
	end_color=$1

	steps=40

	for ((i = 0; i <= steps; i++)); do
		r1=$((16#${start_color:0:2}))
		g1=$((16#${start_color:2:2}))
		b1=$((16#${start_color:4:2}))
		a1=$((16#${start_color:6:2}))

		r2=$((16#${end_color:0:2}))
		g2=$((16#${end_color:2:2}))
		b2=$((16#${end_color:4:2}))
		a2=$((16#${end_color:6:2}))

		r=$((r1 + (i * (r2 - r1)) / steps))
		g=$((g1 + (i * (g2 - g1)) / steps))
		b=$((b1 + (i * (b2 - b1)) / steps))
		a=$((a1 + (i * (a2 - a1)) / steps))

		printf "\e[38;2;%s;%s;%s;%sm—\e[0m" "$r" "$g" "$b" "$a"
	done
	printf "\n"
}

####### CPU NODE #######

cores=$(($(nproc --all) - 1 ))

if [ -f /sys/devices/system/cpu/cputopo/is_big_little ]; then

	export is_big_little=1

	# Get the number of clusters
	nr_clusters=$(cat /sys/devices/system/cpu/cputopo/nr_clusters)

    # Associative array to store CPUs in clusters
    declare -A clusters

    # Loop through each CPU core
    for cpu_dir in /sys/devices/system/cpu/cpu[0-${cores}]*; do
	    core_id=$(basename "$cpu_dir")
	    if [ -f "$cpu_dir/topology/physical_package_id" ]; then
		    core_cluster=$(chmod +r "$cpu_dir/topology/physical_package_id" && cat "$cpu_dir/topology/physical_package_id")
		    clusters[$core_cluster]+=" $core_id"
	    else
		    echo "error: Cannot determine cluster for $core_id" && exit 1
	    fi
    done

    export cluster0=${clusters[0]}
    export cluster1=${clusters[1]}
    if [[ $nr_clusters == 3 ]]; then
	    export cluster2=${clusters[2]}
    fi
else
	export is_big_little=0
fi

cpu_set_gov() {
	if [[ $is_big_little == 1 ]]; then
		if [[ $nr_clusters == 2 ]]; then
			cluster_selected=$(fzf_select "little big" "Select cpu cluster: ")
		elif [[ $nr_clusters == 3 ]]; then
			cluster_selected=$(fzf_select "little big prime" "Select cpu cluster: ")
		fi

		case $cluster_selected in
			little) cpus_need_set=$cluster0 ;;
			big) cpus_need_set=$cluster1 ;;
			prime) cpus_need_set=$cluster2 ;;
		esac

		export gov_selected=$(fzf_select "$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors)" "Select CPU Governor for ${cluster_selected} cluster: ")

		for cpu in $cpus_need_set
		do
			chmod 0644 /sys/devices/system/cpu/${cpu}/cpufreq/scaling_governor && echo $gov_selected > /sys/devices/system/cpu/${cpu}/cpufreq/scaling_governor
		done
	else
		export gov_selected=$(fzf_select "$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors)" "Select CPU Governor for ${cluster_selected} cluster: ")
		for cpu in cpu[0-${cores}]*; do
			chmod 0644 /sys/devices/system/cpu/${cpu}/cpufreq/scaling_governor && echo $gov_selected > /sys/devices/system/cpu/${cpu}/cpufreq/scaling_governor
		done
	fi
}

cpu_set_freq() {
	if [[ $is_big_little == 1 ]]; then
		if [[ $nr_clusters == 2 ]]; then
			cluster_selected=$(fzf_select "little big" "Select cpu cluster: ")
		elif [[ $nr_clusters == 3 ]]; then
			cluster_selected=$(fzf_select "little big prime" "Select cpu cluster: ")
		fi

		case $cluster_selected in
			little) cluster_need_set=0 ;;
			big) cluster_need_set=1;;
			prime) cluster_need_set=2 ;;
		esac

		case $cluster_need_set in
			0) export first_cpu_oncluster=$(echo ${cluster0} | awk '{print $1}')
				export cpus_cluster_selected=${cluster0} ;;
			1) export first_cpu_oncluster=$(echo ${cluster1} | awk '{print $1}')
				export cpus_cluster_selected=${cluster1} ;;
			2) export first_cpu_oncluster=$(echo ${cluster2} | awk '{print $1}')
				export cpus_cluster_selected=${cluster2} ;;
		esac

		if [[ $soc == mtk ]]; then
			echo ${cluster_need_set} $(fzf_select "$(cat /sys/devices/system/cpu/${first_cpu_oncluster}/cpufreq/scaling_available_frequencies)" "Select ${1} CPU freq for ${cluster_selected} cluster: ") > /proc/ppm/policy/hard_userlimit_${1}_cpu_freq
		else
			freq=$(fzf_select "$(cat /sys/devices/system/cpu/${first_cpu_oncluster}/cpufreq/scaling_available_frequencies)" "Select ${1} CPU freq for ${cluster_selected} cluster: ")
			for cpu in ${cpus_cluster_selected}; do
				echo $freq > /sys/devices/system/cpu/${cpu}/cpufreq/scaling_${1}_freq
			done
		fi
	else
		if [[ $soc == mtk ]]; then
			echo 0 $(fzf_select "$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies)" "Select ${1} CPU frequency: ") > /proc/ppm/policy/hard_userlimit_${1}_cpu_freq
		else
			freq=$(fzf_select "$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies)" "Select ${1} CPU frequency: ")
			for cpu in cpu[0-${cores}]*; do
				echo $freq > /sys/devices/system/cpu/${cpu}/cpufreq/scaling_${1}_freq
			done
		fi
	fi
}

cpu_eas_hmp() {
	if [[ $soc == mtk ]]; then
		sched_selected=$(fzf_select "EAS HMP Hybrid" "Select Scheduler: ")
	else
		sched_selected=$(fzf_select "EAS HMP" "Select Scheduler: ")
	fi

	case $sched_selected in
		EAS) export sched=1 ;;
		HMP) export sched=0 ;;
		Hybrid) export sched=2 ;;
	esac

	echo $sched > /sys/devices/system/cpu/eas/enable
}

mtk_cpufreq_cci_mode() {
	case $(fzf_select "Normal Performance" "Mediatek CPU CCI mode: ") in
		Performance) echo 1 > /proc/cpufreq/cpufreq_cci_mode ;;
		Normal) echo 0 > /proc/cpufreq/cpufreq_cci_mode ;;
	esac
}

mtk_cpufreq_power_mode() {
	case $(fzf_select "Normal Low-power Make Performance" "Mediatek CPU CCI mode: ") in
		Performance) echo 3 > /proc/cpufreq/cpufreq_power_mode ;;
		Low-power) echo 1 > /proc/cpufreq/cpufreq_power_mode ;;
		Make) echo 2  > /proc/cpufreq/cpufreq_power_mode ;;
		Normal) echo 0 > /proc/cpufreq/cpufreq_power_mode ;;
	esac
}

mtk_cpu_menu() {
	restorecon -R /sys/devices/system/cpu 2>/dev/null

	loop_helper() {
		clear
		mtk_cpu_menu
	}

	echo -e "${LIGHTCYAN}CPU Control menu\n"
	echo -e "${GREEN}CPU: ${chipset} $(nproc --all) cores"
	echo -e "Arch: $(uname -m)"
	echo -e "Scheduler: $(cat /sys/devices/system/cpu/eas/enable | awk '{print $2}')"
	echo -e "Is big.LITTLE: ${is_big_little}"
	if [[ $is_big_little == 1 ]]; then
		echo -e "big.LITTLE clusters: ${nr_clusters} clusters\n"
		echo -e "LITTLE cluster scaling Governor: $(cat /sys/devices/system/cpu/$(echo ${cluster0} | awk '{print $1}')/cpufreq/scaling_governor)"
		echo -e "BIG cluster scaling Governor: $(cat /sys/devices/system/cpu/$(echo ${cluster1} | awk '{print $1}')/cpufreq/scaling_governor)"
		if [[ $nr_clusters == 3 ]]; then
			echo -e "PRIME cluster scaling Governor: $(cat /sys/devices/system/cpu/$(echo ${cluster2} | awk '{print $1}')/cpufreq/scaling_governor)"
		fi
		echo -e "LITTLE cluster scaling freq: $(cat /sys/devices/system/cpu/$(echo ${cluster0} | awk '{print $1}')/cpufreq/scaling_min_freq)KHz - $(cat /sys/devices/system/cpu/$(echo ${cluster0} | awk '{print $1}')/cpufreq/scaling_max_freq)KHz"
		echo -e "BIG cluster scaling freq: $(cat /sys/devices/system/cpu/$(echo ${cluster1} | awk '{print $1}')/cpufreq/scaling_min_freq)KHz - $(cat /sys/devices/system/cpu/$(echo ${cluster1} | awk '{print $1}')/cpufreq/scaling_max_freq)KHz"
		if [[ $nr_clusters == 3 ]]; then
			echo -e "PRIME cluster scaling freq: $(cat /sys/devices/system/cpu/$(echo ${cluster2} | awk '{print $1}')/cpufreq/scaling_min_freq)KHz - $(cat /sys/devices/system/cpu/$(echo ${cluster2} | awk '{print $1}')/cpufreq/scaling_max_freq)KHz"
		fi
	else
		echo -e "scaling Governor: $(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor)"
		echo -e "scaling freq: $(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq)KHz - $(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq)KHz"
	fi
	echo -e "$(gradient_line 66A8E0ff 94CCF9ff)${NOCOLOR}\n"

	echo -e "${LIGHTCYAN}CPU Utilities:\n"
	echo -e "1) Set Governor\n2) Set max freq\n3) Set min freq\n4) EAS/HMP Scheduler\n5) Mediatek CPU CCI mode\n6) Mediatek CPU Power mode\n0) Back to main menu${NOCOLOR}\n"
	read -p "Select the number: " a1

	case $a1 in
		1) cpu_set_gov
			loop_helper ;;
		2) cpu_set_freq max
			loop_helper ;;
		3) cpu_set_freq min
			loop_helper ;;
		4) cpu_eas_hmp
			loop_helper ;;
		5) mtk_cpufreq_cci_mode
			loop_helper ;;
		6) mtk_cpufreq_power_mode
			loop_helper ;;
		0) clear && main_act ;;
		*) echo -e "error: Invalid selection" && exit 1 ;;
	esac
}

qcom_cpu_menu() {
	restorecon -R /sys/devices/system/cpu 2>/dev/null

	loop_helper() {
		clear
		mtk_cpu_menu
	}

	echo -e "${LIGHTCYAN}CPU Control menu\n"
	echo -e "${GREEN}CPU: ${chipset} $(nproc --all) cores"
	echo -e "Arch: $(uname -m)"
	echo -e "Scheduler: $(cat /sys/devices/system/cpu/eas/enable | awk '{print $2}')"
	echo -e "Is big.LITTLE: ${is_big_little}"
	if [[ $is_big_little == 1 ]]; then
		echo -e "big.LITTLE clusters: ${nr_clusters} clusters\n"
		echo -e "LITTLE cluster scaling Governor: $(cat /sys/devices/system/cpu/$(echo ${cluster0} | awk '{print $1}')/cpufreq/scaling_governor)"
		echo -e "BIG cluster scaling Governor: $(cat /sys/devices/system/cpu/$(echo ${cluster1} | awk '{print $1}')/cpufreq/scaling_governor)"
		if [[ $nr_clusters == 3 ]]; then
			echo -e "PRIME cluster scaling Governor: $(cat /sys/devices/system/cpu/$(echo ${cluster2} | awk '{print $1}')/cpufreq/scaling_governor)"
		fi
		echo -e "LITTLE cluster scaling freq: $(cat /sys/devices/system/cpu/$(echo ${cluster0} | awk '{print $1}')/cpufreq/scaling_min_freq)KHz - $(cat /sys/devices/system/cpu/$(echo ${cluster0} | awk '{print $1}')/cpufreq/scaling_max_freq)KHz"
		echo -e "BIG cluster scaling freq: $(cat /sys/devices/system/cpu/$(echo ${cluster1} | awk '{print $1}')/cpufreq/scaling_min_freq)KHz - $(cat /sys/devices/system/cpu/$(echo ${cluster1} | awk '{print $1}')/cpufreq/scaling_max_freq)KHz"
		if [[ $nr_clusters == 3 ]]; then
			echo -e "PRIME cluster scaling freq: $(cat /sys/devices/system/cpu/$(echo ${cluster2} | awk '{print $1}')/cpufreq/scaling_min_freq)KHz - $(cat /sys/devices/system/cpu/$(echo ${cluster2} | awk '{print $1}')/cpufreq/scaling_max_freq)KHz"
		fi
	else
		echo -e "scaling Governor: $(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor)"
		echo -e "scaling freq: $(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq)KHz - $(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq)KHz"
	fi
	echo -e "$(gradient_line 66A8E0ff 94CCF9ff)${NOCOLOR}\n"

	echo -e "${LIGHTCYAN}CPU Utilities:\n"
	echo -e "1) Set Governor\n2) Set max freq\n3) Set min freq\n4) EAS/HMP Scheduler\n0) Back to main menu${NOCOLOR}\n"
	read -p "Select the number: " a1

	case $a1 in
		1) cpu_set_gov
			loop_helper ;;
		2) cpu_set_freq max
			loop_helper ;;
		3) cpu_set_freq min
			loop_helper ;;
		4) cpu_eas_hmp
			loop_helper ;;
		0) clear && main_act ;;
		*) echo -e "error: Invalid selection" && exit 1 ;;
	esac
}

cpu_menu() {
	case $soc in
		mtk) mtk_cpu_menu ;;
		qcom) qcom_cpu_menu ;;
	esac
}

####### GPU NODE #######

mtk_gpu_freq_set() {
	echo $(fzf_select "0 $(cat /proc/gpufreq/gpufreq_opp_dump | grep -o 'freq = [0-9]*' | sed 's/freq = //' | sort -n)" "Set frequency for GPU (NO DVFS): ") > /proc/gpufreq/gpufreq_opp_freq 2>/dev/null
}

mtk_gpu_power_policy() {
	echo $(fzf_select "$(cat /sys/devices/platform/13040000.mali/power_policy | sed 's/\[//g; s/\]//g')" "Select GPU power policy: ") > /sys/devices/platform/13040000.mali/power_policy
}

mtk_gpu_serialize_jobs() {
	echo $(fzf_select "$(cat /sys/devices/platform/13040000.mali/scheduling/serialize_jobs | sed 's/\(\[[^]]*\]\)\([^[:space:]]\)/\1 \2/g; s/\[\|\]//g')" "Select GPU power policy: ") > /sys/devices/platform/13040000.mali/scheduling/serialize_jobs
}

# TODO: Create menu for Mediatek's GED

mtk_gpu_menu() {

	loop_helper() {
		clear
		mtk_gpu_menu
	}

	echo -e "GPU Control menu\n"
	echo -e "GPU: $(cat /sys/devices/platform/13040000.mali/gpuinfo)"
	echo -e "DVFS scaling frequency: $(cat /proc/gpufreq/gpufreq_opp_dump | grep -o 'freq = [0-9]*' | sed 's/freq = //' | sort -n | awk 'NR==1{low=$1} END{high=$1} END{print low "KHz - " high "KHz"}')"
	echo -e "$(gradient_line 66A8E0ff 94CCF9ff)\n"
	echo -e "GPU utilities:\n"
	echo -e "1) Set frequency (NO DVFS)\n2) GPU Power policy\n3) GPU serialize jobs\n4) GPU Extension Device menu\n0) Back to main menu\n"
	read -p "Select the number: " a1
	case $a1 in
		1) mtk_gpu_freq_set
			loop_helper ;;
		2) mtk_gpu_power_policy
			loop_helper ;;
		3) mtk_gpu_serialize_jobs
			loop_helper ;;
		4) clear
			mtk_ged_menu ;;
		0) clear && main_act ;;
		*) echo -e "error: Invalid selection" && exit 1 ;;
	esac
}

gpu_menu() {
	case $soc in
		mtk) mtk_gpu_menu ;;
		qcom) qcom_gpu_menu ;;
	esac
}

####### DISP NODE #######

mtk_videox_livedisplay() {
	R=$(cat /sys/devices/platform/mtk_disp_mgr.0/rgb | awk '{print $1}')
	G=$(cat /sys/devices/platform/mtk_disp_mgr.0/rgb | awk '{print $2}')
	B=$(cat /sys/devices/platform/mtk_disp_mgr.0/rgb | awk '{print $3}')
	curr_color="R"

	echo -e "MTK Videox Livedisplay"
	echo -e "Display color control for Mediatek devices\n$(gradient_line 66A8E0ff 94CCF9ff)\n"
	echo -e "Use ( ↑ ↓ ) to increase or decrease value\nUse ( ← → ) to move\nUse HOME or END to exit\n"
	echo -e "$(color_blocks)\n"
	echo -e "${RED}Red\t${GREEN}Green\t${BLUE}Blue${NOCOLOR}"

	print_colors() {
		printf "\r%s\t%s\t%s" "$R" "$G" "$B"

		if [ "$curr_color" = "R" ]; then
			printf "\n\r%s\t%s\t%s" "^" " " " "
		elif [ "$curr_color" = "G" ]; then
			printf "\n\r%s\t%s\t%s" " " "^" " "
		else
			printf "\n\r%s\t%s\t%s" " " " " "^"
		fi

# Make the cursor invisible
tput civis
# moves the cursor up one line
tput cuu1
# stores the positon of cursor
tput sc
}

while true; do
	print_colors
	read -r -sN3 t
	case "${t:2:1}" in
		A)
			if [ "$curr_color" = "R" ] && ((R < 2000)); then
				((R++))
			elif [ "$curr_color" = "G" ] && ((G < 2000)); then
				((G++))
			elif [ "$curr_color" = "B" ] && ((B < 2000)); then
				((B++))
			fi
			;;
		B)
			if [ "$curr_color" = "R" ] && ((R > 1)); then
				((R--))
			elif [ "$curr_color" = "G" ] && ((G > 1)); then
				((G--))
			elif [ "$curr_color" = "B" ] && ((B > 1)); then
				((B--))
			fi
			;;
		C)
			if [ "$curr_color" = "R" ]; then
				curr_color="G"
			elif [ "$curr_color" = "G" ]; then
				curr_color="B"
			else
				curr_color="R"
			fi
			;;
		D)
			if [ "$curr_color" = "R" ]; then
				curr_color="B"
			elif [ "$curr_color" = "G" ]; then
				curr_color="R"
			else
				curr_color="G"
			fi
			;;
		*) break ;;
	esac

	echo $R $G $B > /sys/devices/platform/mtk_disp_mgr.0/rgb 2>/dev/null
done

# Normalize cursor
echo -e "\n"
tput cnorm
}

qcom_kcal_ctrl() {
	R=$(cat /sys/devices/platform/kcal_ctrl.0/kcal | awk '{print $1}')
	G=$(cat /sys/devices/platform/kcal_ctrl.0/kcal | awk '{print $2}')
	B=$(cat /sys/devices/platform/kcal_ctrl.0/kcal | awk '{print $3}')
	invert=$(cat /sys/devices/platform/kcal_ctrl.0/kcal_invert)
	sat=$(cat /sys/devices/platform/kcal_ctrl.0/kcal_sat)
	hue=$(cat /sys/devices/platform/kcal_ctrl.0/kcal_hue)
	val=$(cat /sys/devices/platform/kcal_ctrl.0/kcal_val)
	cont=$(cat /sys/devices/platform/kcal_ctrl.0/kcal_cont)
	curr_color="R"

	echo -e "qcom kcal color control"
	echo -e "Display color control for Snapdragon devices\n$(gradient_line 66A8E0ff 94CCF9ff)\n"
	echo -e "Use ( ↑ ↓ ) to increase or decrease value\nUse ( ← → ) to move\nUse HOME or END to exit\n"
	echo -e "$(color_blocks)\n"
	echo -e "${RED}Red\t${GREEN}Green\t${BLUE}Blue${BLACKBGWHITE}\tInvert${NOCOLOR}\tSaturation${CYAN}\tHue\tVal\tContrast${NOCOLOR}"

	print_colors() {
		printf "\r%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s" "$R" "$G" "$B" "$invert" "$sat" "$hue" "$val" "$cont"

		case "$curr_color" in
			"R")
				printf "\r%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s" "^" " " " " " " " " " " " " " "
				;;
			"G")
				printf "\r%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s" " " "^" " " " " " " " " " " " "
				;;
			"B")
				printf "\r%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s" " " " " "^" " " " " " " " " " "
				;;
			"invert")
				printf "\r%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s" " " " " " " "^" " " " " " " " "
				;;
			"sat")
				printf "\r%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s" " " " " " " " "^" " " " " " " "
				;;
			"hue")
				printf "\r%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s" " " " " " " " " " " "^" " " " "
				;;
			"val")
				printf "\r%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s" " " " " " " " " " " " " "^" " "
				;;
			*)
				printf "\r%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s" " " " " " " " " " " " " " " "^"
				;;
		esac

# Make the cursor invisible
tput civis
# moves the cursor up one line
tput cuu1
# stores the positon of cursor
tput sc
}

while true; do
	print_colors
	read -r -sN3 t
	case "${t:2:1}" in
		A)
			if [ "$curr_color" = "R" ] && ((R < 256)); then
				((R++))
			elif [ "$curr_color" = "G" ] && ((G < 256)); then
				((G++))
			elif [ "$curr_color" = "B" ] && ((B < 256)); then
				((B++))
			elif [ "$curr_color" = "invert" ] && ((B < 1)); then
				((invert++))
			elif [ "$curr_color" = "sat" ] && ((B < 383)); then
				((sat++))
			elif [ "$curr_color" = "hue" ] && ((B < 1536)); then
				((hue++))
			elif [ "$curr_color" = "val" ] && ((B < 383)); then
				((val++))
			elif [ "$curr_color" = "cont" ] && ((B < 383)); then
				((cont++))
			fi
			;;
		B)
			if [ "$curr_color" = "R" ] && ((R > 1)); then
				((R--))
			elif [ "$curr_color" = "G" ] && ((G > 1)); then
				((G--))
			elif [ "$curr_color" = "B" ] && ((B > 1)); then
				((B--))
			elif [ "$curr_color" = "invert" ] && ((B < 0)); then
				((invert--))
			elif [ "$curr_color" = "sat" ] && ((B < 224)); then
				((sat--))
			elif [ "$curr_color" = "hue" ] && ((B < 0)); then
				((hue--))
			elif [ "$curr_color" = "val" ] && ((B < 128)); then
				((val--))
			elif [ "$curr_color" = "cont" ] && ((B < 128)); then
				((cont--))
			fi
			;;
		C)
			if [ "$curr_color" = "R" ]; then
				curr_color="G"
			elif [ "$curr_color" = "G" ]; then
				curr_color="B"
			elif [ "$curr_color" = "B" ]; then
				curr_color="invert"
			elif [ "$curr_color" = "invert" ]; then
				curr_color="sat"
			elif [ "$curr_color" = "sat" ]; then
				curr_color="hue"
			elif [ "$curr_color" = "hue" ]; then
				curr_color="val"
			elif [ "$curr_color" = "val" ]; then
				curr_color=cont
			else
				curr_color="R"
			fi
			;;
		D)
			if [ "$curr_color" = "R" ]; then
				curr_color="cont"
			elif [ "$curr_color" = "G" ]; then
				curr_color="R"
			elif [ "$curr_color" = "B" ]; then
				curr_color="G"
			elif [ "$curr_color" = "invert" ]; then
				curr_color="B"
			elif [ "$curr_color" = "sat" ]; then
				curr_color="invert"
			elif [ "$curr_color" = "hue" ]; then
				curr_color="sat"
			elif [ "$curr_color" = "val" ]; then
				curr_color="hue"
			else
				curr_color="R"
			fi
			;;
		*) break ;;
	esac

	echo $R $G $B > /sys/devices/platform/kcal_ctrl.0/kcal 2>/dev/null
	echo $invert > /sys/devices/platform/kcal_ctrl.0/kcal_invert
	echo $sat > /sys/devices/platform/kcal_ctrl.0/kcal_sat
	echo $hue > /sys/devices/platform/kcal_ctrl.0/kcal_hue
	echo $val > /sys/devices/platform/kcal_ctrl.0/kcal_val
	echo $cont > /sys/devices/platform/kcal_ctrl.0/kcal_cont
done

# Normalize cursor
echo -e "\n"
tput cnorm
}

disp_menu() {
	if [[ $soc == mtk && -f /sys/devices/platform/mtk_disp_mgr.0/rgb ]]; then
		mtk_videox_livedisplay
	elif [[ $soc == qcom && -f /sys/devices/platform/kcal_ctrl.0/kcal ]]; then
		qcom_kcal_ctrl
	else
		echo -e "Your Kernel/Device combination doesn't support any display control feature" && exit 1
	fi

	main_act
}

####### BATTERY NODE #######

# TODO: Add charging switch tester
#charging_swiches=()

mtk_idle_charging() {
	case $(fzf_select "Enable Disable" "Idle charging: ") in
		Enable) echo $(cat /proc/mtk_battery_cmd/current_cmd | awk '{print $1}') 1 > /proc/mtk_battery_cmd/current_cmd
			echo 0 > /proc/mtk_battery_cmd/en_power_path ;;
		Disable) echo $(cat /proc/mtk_battery_cmd/current_cmd | awk '{print $1}') 0 > /proc/mtk_battery_cmd/current_cmd
			echo 1 > /proc/mtk_battery_cmd/en_power_path ;;
	esac
}

mtk_limit_charging_current() {
	case $(fzf_select "Enable Disable" "Unlimit charging current: ") in
		Enable) echo 1 $(cat /proc/mtk_battery_cmd/current_cmd | awk '{print $2}') > /proc/mtk_battery_cmd/current_cmd ;;
		Disable) echo 0 $(cat /proc/mtk_battery_cmd/current_cmd | awk '{print $2}') > /proc/mtk_battery_cmd/current_cmd ;;
	esac
}

mtk_battery_menu() {

	loop_helper() {
		clear
		mtk_battery_menu
	}

	echo -e "${CYAN}Battery menu\n"
	echo -e "Status: $(cat /sys/class/power_supply/battery/status)"
	echo -e "Technology: $(cat /sys/class/power_supply/battery/technology)"
	echo -e "Health: $(cat /sys/class/power_supply/battery/health)"
	echo -e "Capacity: $(cat /sys/class/power_supply/battery/charge_full) mAh"
	echo -e "$(gradient_line 66A8E0ff 94CCF9ff)${NOCOLOR}\n"

# It's should be fine to say all Mediatek kernels supported idle charging
# though procfs 'mtk_battery_cmd', no testing needed.
echo -e "1) Idle charging\n2) Limit charging current\n0) Back to main menu\n"
read -p "Select the number: " a1

case $a1 in
	1) mtk_idle_charging
		loop_helper ;;
	2) mtk_limit_charging_current
		loop_helper ;;
	0) clear && main_act ;;
	*) echo -e "error: Invalid selection" && exit 1 ;;
esac
}

battery_menu() {
	case $soc in
		mtk) mtk_battery_menu ;;
		qcom) qcom_battery_menu ;;
	esac
}

####### NETWORKING NODE #######

tcp_congestion_change() {
	echo $(fzf_select "$(cat /proc/sys/net/ipv4/tcp_available_congestion_control)" "Select TCP Congestion: ") > /proc/sys/net/ipv4/tcp_congestion_control
}

tcp_low_latency() {
	case $(fzf_select "Enable Disable" "TCP Low latency mode: ") in
		Enable) echo 1 > /proc/sys/net/ipv4/tcp_low_latency ;;
		Disable) echo 0 > /proc/sys/net/ipv4/tcp_low_latency ;;
	esac
}

tcp_syncookies() {
	case $(fzf_select "Enable Disable" "SYN Cookies: ") in
		Enable) echo 1 > /proc/sys/net/ipv4/tcp_syncookies ;;
		Disable) echo 0 > /proc/sys/net/ipv4/tcp_syncookies ;;
	esac
}

tcp_max_syn_backlog() {
	echo -e "TCP Max SYN Backlog"
	echo -e "maximum number of TCP SYN (synchronization) requests that\ncan be pending at any given time. Higer value means more\nconnection rates also higher memory consumption.\n"
	echo -e "Use ( ↑ ↓ ) to increase or decrease value\nUse HOME or END to exit\n"

	number=$(cat /proc/sys/net/ipv4/tcp_max_syn_backlog)

	print_number() {
		printf "\r%s%s" "value: " "$number   "
	}

	while true; do
		print_number
		read -r -sN3 t
		case "${t:2:1}" in
			A)
				if ((number < 32400)); then
					((number++))
				fi
				;;
			B)
				if ((number > 128)); then
					((number--))
				fi
				;;
			*) break ;;
		esac

		echo $number > /proc/sys/net/ipv4/tcp_max_syn_backlog
	done
}

tcp_keepalive_time() {
	echo -e "TCP Keep alive time"
	echo -e "waits before sending keepalive probes to verify connections\nare still active. Reducing this value can help detect inactive\nconnections faster and free up resources. be careful not to set\nit too low as it can increase network traffic and CPU usage.\n"
	echo -e "Use ( ↑ ↓ ) to increase or decrease value\nUse HOME or END to exit\n"

	number=$(cat /proc/sys/net/ipv4/tcp_max_syn_backlog)

	print_number() {
		printf "\r%s%s" "value: " "$number   "
	}

	while true; do
		print_number
		read -r -sN3 t
		case "${t:2:1}" in
			A)
				if ((number < 32400)); then
					((number++))
				fi
				;;
			B)
				if ((number > 128)); then
					((number--))
				fi
				;;
			*) break ;;
		esac

		echo $number > /proc/sys/net/ipv4/tcp_max_syn_backlog
	done
}

tcp_reuse_socket() {
	case $(fzf_select "Enable Disable enable-for-loopback-traffic-only" "TCP Reuse socket: ") in
		Enable) echo 1 > /proc/sys/net/ipv4/tcp_tw_reuse ;;
		Disable) echo 0 > /proc/sys/net/ipv4/tcp_tw_reuse ;;
		enable-for-loopback-traffic-only) echo 2 > /proc/sys/net/ipv4/tcp_tw_reuse ;;
	esac
}

networking_menu() {

	loop_helper() {
		clear
		networking_menu
	}

	echo -e "Networking and Firewall settings\n"
	echo -e "1) Change TCP Congestion algorithm\n2) TCP Low latency mode\n3) TCP SYN Cookies\n4) TCP Max SYN backlog\n5) TCP Keep alive time\n6) TCP Reuse socket\n0) Back to main menu\n"
	read -p "Select the number: " a1

	case $a1 in
		1) tcp_congestion_change
			loop_helper ;;
		2) tcp_low_latency
			loop_helper ;;
		3) tcp_syncookies
			loop_helper ;;
		4) clear
			tcp_max_syn_backlog
			loop_helper ;;
		5) clear
			tcp_keepalive_time
			loop_helper ;;
		6) tcp_reuse_socket
			loop_helper ;;
		0) clear && main_act ;;
		*) echo -e "error: Invalid selection" && exit 1 ;;
	esac
}

####### MEMORY NODE #######

memory_drop_cache() {
	echo $(fzf_select "0 1 2 3" "Memory drop cache mode: ") > /proc/sys/vm/drop_caches
}

memory_swappiness() {
	echo -e "Swappiness"
	echo -e "Define the rough relative IO cost of swapping and filesystem paging, as a value between 0 and 200. lower values signify more expensive swap IO, higher values indicates cheaper.\n"
	echo -e "Use ( ↑ ↓ ) to increase or decrease value\nUse HOME or END to exit\n"

	number=$(cat /proc/sys/vm/swappiness)

	print_number() {
		printf "\r%s%s" "value: " "$number   "
	}

	while true; do
		print_number
		read -r -sN3 t
		case "${t:2:1}" in
			A)
				if ((number < 200)); then
					((number++))
				fi
				;;
			B)
				if ((number > 0)); then
					((number--))
				fi
				;;
			*) break ;;
		esac

		echo $number > /proc/sys/vm/swappiness
	done
}

min_free_kbytes() {
	echo -e "Minimal free kbytes"
	echo -e "Force the Linux VM to keep a minimum number of kilobytes free. Setting this too high will OOM your machine instantly.\n"
	echo -e "Use ( ↑ ↓ ) to increase or decrease value\nUse HOME or END to exit\n"

	number=$(cat /proc/sys/vm/min_free_kbytes)

	print_number() {
		printf "\r%s%s" "value: " "$number   "
	}

	while true; do
		print_number
		read -r -sN3 t
		case "${t:2:1}" in
			A)
				if ((number < 11520)); then
					((number += 4))
				fi
				;;
			B)
				if ((number > 128)); then
					((number -= 4))
				fi
				;;
			*) break ;;
		esac

		echo $number > /proc/sys/vm/min_free_kbytes
	done
}

extra_free_kbytes() {
	echo -e "Minimal free kbytes"
	echo -e "Tell the VM to keep an extra amount of memory free, by increasing the gap between each zone's min and low watermarks.\n"
	echo -e "Use ( ↑ ↓ ) to increase or decrease value\nUse HOME or END to exit\n"

	number=$(cat /proc/sys/vm/extra_free_kbytes)

	print_number() {
		printf "\r%s%s" "value: " "$number   "
	}

	while true; do
		print_number
		read -r -sN3 t
		case "${t:2:1}" in
			A)
				if ((number < 11520)); then
					((number += 4))
				fi
				;;
			B)
				if ((number > 128)); then
					((number -= 4))
				fi
				;;
			*) break ;;
		esac

		echo $number > /proc/sys/vm/extra_free_kbytes
	done
}

laptop_mode() {
	echo $(fzf_select "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15" "Laptop mode: ") > /proc/sys/vm/laptop_mode
}

oom_kill_alloc() {
	case $(fzf_select "Yes No" "Kill allocating task: ") in
		Yes) echo 1 > /proc/sys/vm/oom_kill_allocating_task ;;
		No) echo 0 > /proc/sys/vm/oom_kill_allocating_task ;;
	esac
}

vfs_cache_pressure() {
	echo -e "VFS Pressure cache"
	echo -e "Controls the tendency of the kernel to reclaim the memory which is used for caching of directory and inode objects.\n"
	echo -e "Use ( ↑ ↓ ) to increase or decrease value\nUse HOME or END to exit\n"

	number=$(cat /proc/sys/vm/vfs_cache_pressure)

	print_number() {
		printf "\r%s%s" "value: " "$number   "
	}

	while true; do
		print_number
		read -r -sN3 t
		case "${t:2:1}" in
			A)
				if ((number < 1024)); then
					((number++))
				fi
				;;
			B)
				if ((number > 8)); then
					((number--))
				fi
				;;
			*) break ;;
		esac

		echo $number > /proc/sys/vm/vfs_cache_pressure
	done
}

overcommit_ratio() {
	echo -e "Overcommit ratio"
	echo -e "Determines the memory overcommit policy. It's represented as a percentage and dictates the ratio by which virtual memory may exceed physical RAM.\n"
	echo -e "Use ( ↑ ↓ ) to increase or decrease value\nUse HOME or END to exit\n"

	number=$(cat /proc/sys/vm/overcommit_ratio)

	print_number() {
		printf "\r%s%s" "value: " "$number   "
	}

	while true; do
		print_number
		read -r -sN3 t
		case "${t:2:1}" in
			A)
				if ((number < 100)); then
					((number++))
				fi
				;;
			B)
				if ((number > 1)); then
					((number--))
				fi
				;;
			*) break ;;
		esac

		echo $number > /proc/sys/vm/overcommit_ratio
	done
}

dirty_ratio() {
	echo -e "Dirty ratio"
	echo -e "Percentage of total available memory that contains free pages and reclaimable pages, the number of pages at which a process which is generating disk writes will itself start writing out dirty data.\n"
	echo -e "Use ( ↑ ↓ ) to increase or decrease value\nUse HOME or END to exit\n"

	number=$(cat /proc/sys/vm/dirty_ratio)

	print_number() {
		printf "\r%s%s" "value: " "$number   "
	}

	while true; do
		print_number
		read -r -sN3 t
		case "${t:2:1}" in
			A)
				if ((number < 100)); then
					((number++))
				fi
				;;
			B)
				if ((number > 1)); then
					((number--))
				fi
				;;
			*) break ;;
		esac

		echo $number > /proc/sys/vm/dirty_ratio
	done
}

dirty_background_ratio() {
	echo -e "Dirty background ratio"
	echo -e "Percentage of total available memory that contains free pages and reclaimable pages, the number of pages at which the background kernel flusher threads will start writing out dirty data.\n"
	echo -e "Use ( ↑ ↓ ) to increase or decrease value\nUse HOME or END to exit\n"

	number=$(cat /proc/sys/vm/dirty_background_ratio)

	print_number() {
		printf "\r%s%s" "value: " "$number   "
	}

	while true; do
		print_number
		read -r -sN3 t
		case "${t:2:1}" in
			A)
				if ((number < 100)); then
					((number++))
				fi
				;;
			B)
				if ((number > 1)); then
					((number--))
				fi
				;;
			*) break ;;
		esac

		echo $number > /proc/sys/vm/dirty_background_ratio
	done
}

dirty_writeback_centisecs() {
	echo -e "Dirty writeback centisecs"
	echo -e "The kernel flusher threads will periodically wake up and write old data out to disk. This tunable expresses the interval between those wakeups, in 100'ths of a second. Setting this to zero disables periodic writeback altogether.\n"
	echo -e "Use ( ↑ ↓ ) to increase or decrease value\nUse HOME or END to exit\n"

	number=$(cat /proc/sys/vm/dirty_writeback_centisecs)

	print_number() {
		printf "\r%s%s" "value: " "$number   "
	}

	while true; do
		print_number
		read -r -sN3 t
		case "${t:2:1}" in
			A)
				if ((number < 1000)); then
					((number +=10))
				fi
				;;
			B)
				if ((number > 10)); then
					((number -=10))
				fi
				;;
			*) break ;;
		esac

		echo $number > /proc/sys/vm/dirty_writeback_centisecs
	done
}

dirty_expire_centisecs() {
	echo -e "Dirty expire centisecs"
	echo -e "Define when dirty data is old enough to be eligible for writeout by the kernel flusher threads. It is expressed in 100'ths of a second.\n"
	echo -e "Use ( ↑ ↓ ) to increase or decrease value\nUse HOME or END to exit\n"

	number=$(cat /proc/sys/vm/dirty_expire_centisecs)

	print_number() {
		printf "\r%s%s" "value: " "$number   "
	}

	while true; do
		print_number
		read -r -sN3 t
		case "${t:2:1}" in
			A)
				if ((number < 30000)); then
					((number +=50))
				fi
				;;
			B)
				if ((number > 100)); then
					((number -=50))
				fi
				;;
			*) break ;;
		esac

		echo $number > /proc/sys/vm/dirty_expire_centisecs
	done
}

# TODO: Add MGLRU and KSM menu

memory_menu() {

	loop_helper() {
		clear
		memory_menu
	}

	echo -e "Memory settings memu\n"
	echo -e "1) Memory cache drop mode\n2) Swappiness\n3) Minimal free kbytes\n4) Extra free kbytes\n5) Laptop mode\n6) OOM Kill allocating task\n7) VFS Pressure cache\n8) Overcommit memory ratio\n9) Dirty ratio\n10) Dirty background ratio\n11) Dirty writeback centisecs\n12) Dirty expire centisecs\n0) Back to main menu\n"
	if [[ -d /sys/kernel/mm/lru_gen ]]; then
		echo -e "Your kernel also support for Multi-Gen LRU, type 'mglru' for enter the mglru menu.\n"
	fi

	if [[ -d /sys/kernel/mm/ksm ]]; then 
		echo -e "Your kernel also support for kernel samepage merging, type 'ksm' for enter the ksm menu.\n"
	fi
	read -p "Select the number: " a1

	case $a1 in
		1) clear
			memory_drop_cache
			loop_helper ;;
		2) clear
			memory_swappiness
			loop_helper ;;
		3) clear
			min_free_kbytes
			loop_helper ;;
		4) clear
			extra_free_kbytes
			loop_helper ;;
		5) clear
			laptop_mode
			loop_helper ;;
		6) clear
			oom_kill_alloc
			loop_helper ;;
		7) clear
			vfs_cache_pressure
			loop_helper ;;
		8) clear
			overcommit_ratio
			loop_helper ;;
		9) clear
			dirty_ratio
			loop_helper ;;
		10) clear
			dirty_background_ratio
			loop_helper ;;
		11) clear
			dirty_writeback_centisecs
			loop_helper ;;
		12) clear
			dirty_expire_centisecs
			loop_helper ;;
		0) clear && main_act ;;
		mglru) clear
			mglru_menu
			loop_helper ;;
		ksm) clear
			ksm_menu
			loop_helper ;;
		*) echo -e "error: Invalid selection" && exit 1
	esac
}

####### STORAGE IO NODE #######

io_sched_change() {
	export block_target=$(fzf_select "mmcblk0 mmcblk1 dm-0" "Select block you wanted to change I/O sched: ")
	echo $(fzf_select "$(cat /sys/block/${block_target}/queue/scheduler | sed 's/\[//g; s/\]//g')" "Select I/O Scheduler: ") > /sys/block/${block_target}/queue/scheduler
}

storage_io_menu() {

	loop_helper() {
		clear
		storage_io_menu
	}

	echo -e "Storage and I/O menu\n"
	echo -e "1) Change I/O scheduler\n0) Back to main menu\n"
	read -p "Select the number: " a1

	case $a1 in
		1) io_sched_change
			loop_helper ;;
		0) clear && main_act ;;
		*) echo -e "error: Invalid selection" && exit 1 ;;
	esac
}

####### MANUFACTURER SPECIFIC NODE #######

oplus_touchscreen() {
	echo -e "Oplus touchscreen menu\nPropertiary touchscreen driver for Oppo/Realme/OnePlus/s devices\n"
	echo -e "1) Game mode\n2) Double tap to wake\n3) Direction fix\n4) Touch sampling rate limit\n0) Back to Manufacturer menu\n"
	read -p "Select the number: " a1

	case $a1 in
		1)
			case $(fzf_select "Enable Disable" "Touchpanel Game mode: ") in
				Enable) echo 1 > /proc/touchpanel/game_switch_enable ;;
				Disable) echo 0 > /proc/touchpanel/game_switch_enable ;;
			esac
			;;
		2) 
			case $(fzf_select "Enable Disable" "Double tap to wake: ") in
				Enable) echo 1 > /proc/touchpanel/double_tap_enable ;;
				Disable) echo 0 > /proc/touchpanel/double_tap_enable ;;
			esac
			;;
		3)
			case $(fzf_select "Enable Disable" "Touchpanel Direction fix: ") in
				Enable) echo 1 > /proc/touchpanel/oplus_tp_direction ;;
				Disable) echo 0 > /proc/touchpanel/oplus_tp_direction ;;
			esac
			;;
		4) 
			case $(fzf_select "Enable Disable" "Touchpanel sampling rate limit: ") in
				Enable) echo 1 > /proc/touchpanel/oplus_tp_limit_enable ;;
				Disable) echo 0 > /proc/touchpanel/oplus_tp_limit_enable ;;
			esac
			;;
		0) clear && oem_mods_menu ;;
		*) echo -e "error: Invalid selection" && exit 1 ;;
	esac

	clear
	oplus_touchscreen
}

oppo_disp_brigthness() {
	echo -e "Oppo display brightnees"
	echo -e "Just regular display brightness setting\n"
	echo -e "Use ( ↑ ↓ ) to increase or decrease value\nUse HOME or END to exit\n"

	max=$(cat /sys/kernel/oppo_display/oppo_max_brightness)
	number=$(cat /sys/kernel/oppo_display/oppo_brightness)

	print_number() {
		printf "\r%s%s" "value: " "$number   "
	}

	while true; do
		print_number
		read -r -sN3 t
		case "${t:2:1}" in
			A)
				if ((number < max)); then
					((number += 10))
					if ((number > max)); then
						number=$max
					fi
				fi
				;;
			B)
				if ((number > 10)); then
					((number -= 10))
				fi
				;;
			*) break ;;
		esac

		echo $number > /sys/kernel/oppo_display/oppo_brightness
	done
}

oppo_display_aod() {
	echo -e "Available soonn..." && exit 0
}

oppo_disp() {

	loop_helper() {
		clear
		oppo_disp
	}

	echo -e "Oppo display menu\nPropertiary display driver for Oppo/Realme/OnePlus/s devices\nSome settings may ovewriten by your ROM.\n"
	echo -e "1) Brigthness settings\n2) AOD settings\n0) Back to Manufacturer specific menu\n"
	read -p "Select the number: " a1

	case $a1 in
		1) clear 
			oppo_disp_brigthness
			loop_helper ;;
		2) clear
			oppo_display_aod
			loop_helper ;;
		0) clear && oem_mods_menu ;;
		*) echo -e "error: Invalid selection" && exit 1 ;;
	esac
}

mtk_vibrator_ctrl() {
	if [ ! -d /sys/kernel/thunderquake_engine ]; then
		echo -e "Your kernel doesn't support this feature" && exit 1
	fi

	echo -e "Mediatek Vibrator control"
	echo -e "Set strength of vibration globally on Mediatek devices\n"
	echo -e "$(cat /sys/kernel/thunderquake_engine/engine_version)\n"
	echo -e "Use ( ↑ ↓ ) to increase or decrease value\nUse HOME or END to exit\n"

	number=$(cat /sys/kernel/thunderquake_engine/level)
	max=$(cat /sys/kernel/thunderquake_engine/max)
	min=$(cat /sys/kernel/thunderquake_engine/min)

	print_number() {
		printf "\r%s%s" "value: " "$number   "
	}

	while true; do
		print_number
		read -r -sN3 t
		case "${t:2:1}" in
			A)
				if ((number < max)); then
					((number++))
				fi
				;;
			B)
				if ((number > min)); then
					((number--))
				fi
				;;
			*) break ;;
		esac

		echo $number > /sys/kernel/thunderquake_engine/level
	done
}

oem_mods_menu() {

	loop_helper() {
		clear
		oem_mods_menu
	}

	manufacturer=$(getprop "ro.product.brand")

	echo -e "Manufacturer specific menu\n"
	echo -e "Device manufacturer: $manufacturer"
	echo -e "SoC Manufacturer: $soc"
	echo -e "$(gradient_line 66A8E0ff 94CCF9ff)\n"
	echo -e "Utilities:\n"

	if [[ $manufacturer == *realme* || $manufacturer == *oppo* || $manufacturer == *oplus* ]]; then
		echo -e "1) Oplus touchscreen\n2) Oppo display\n0) Back to main menu"
	fi

	if [[ $soc == mtk ]]; then
		echo -e "a) Vibrator strength control"
	fi

	echo -e "\n"
	read -p "Select the option: " a1

	if [[ $manufacturer == *realme* || $manufacturer == *oppo* || $manufacturer == *oplus* ]]; then
		case $a1 in
			1) clear 
				oplus_touchscreen ;;
			2) clear 
				oppo_disp ;;
		esac
	fi

	if [[ $soc == mtk ]]; then
		case $a1 in
			[Aa]*) clear
				mtk_vibrator_ctrl 
				loop_helper ;;
		esac
	fi

	case $a1 in
		0) clear && main_act ;;
		*) echo -e "error: Invalid selection" && exit 1 ;;
	esac
}

####### MAIN NODE #######

main_act() {
	clear
	echo -e "${LIGHTCYAN}Origami Kernel Manager v1.0\n"
	echo -e "Copyright (c) 2023-2024 Rem01Gaming."
	echo -e "This is free software with ${LIGHTRED}ABSOLUTELY NO WARRANTY.${LIGHTCYAN}"
	echo -e "Wrong configuration could possibly harm your device !${BLUE}"
	echo -e "$(gradient_line 66A8E0ff 94CCF9ff)${NOCOLOR}\n"

	if hash neofetch 2>/dev/null; then
		neofetch
	else
		echo -e "${LIGHTGREEN}Kernel: $(uname -r)"
		echo -e "Uptime: $(uptime -p)${NOCOLOR}\n"
	fi

	echo -e "${LIGHTCYAN}What can I do for you today?\n"
	echo -e "1) Manufacturer specific settings\n2) CPU Control\n3) GPU Control\n4) Battery settings\n5) Memory settings\n6) Networking and Firewall settings\n7) Storage and I/O related\n8) Display control\n0) Exit${NOCOLOR}\n"
	read -p "Select the number: " a1

	case $a1 in
		1) clear
			oem_mods_menu
			;;
		2) clear
			cpu_menu
			;;
		3) clear
			gpu_menu
			;;
		4) clear
			battery_menu
			;;
		5) clear
			memory_menu
			;;
		6) clear
			networking_menu
			;;
		7) clear
			storage_io_menu
			;;
		8) clear
			disp_menu
			;;
		0) clear && exit 0 ;;
		*) echo -e "error: Invalid selection." && exit 1 ;;
	esac
}

# Main logic
which_chipset
main_act
